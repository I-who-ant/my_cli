# 命令别名实现方案 - 将 `my_cli` 简写为 `mc`

## 🎯 需求

将 `my_cli` 命令简化为 `mc`，像 `.bashrc` 中的别名一样使用。

```bash
# 原来
my_cli -c "Hello World"

# 简化后
mc -c "Hello World"
```

---

## 📋 三种实现方案对比

| 方案 | 优点 | 缺点 | 推荐度 |
|------|------|------|--------|
| **方案1：Shell 别名** | 最简单，立即生效 | 仅限当前用户和 shell | ⭐⭐⭐⭐⭐ |
| **方案2：多入口点** | 真正的命令，全局可用 | 需要重新安装包 | ⭐⭐⭐⭐ |
| **方案3：符号链接** | 不需修改代码 | conda 环境特定 | ⭐⭐⭐ |

---

## 🚀 方案1：Shell 别名（推荐）

### 原理

在 shell 配置文件中添加别名，shell 会自动将 `mc` 替换为 `my_cli`。

### 实现步骤

#### 1. 编辑 `.bashrc` 或 `.bash_aliases`

```bash
# 打开 .bashrc
vim ~/.bashrc

# 或者 .bash_aliases（如果存在）
vim ~/.bash_aliases
```

#### 2. 添加别名

在文件末尾添加：

```bash
# My CLI 命令别名
alias mc='my_cli'
```

#### 3. 重新加载配置

```bash
# 方法1：重新加载 .bashrc
source ~/.bashrc

# 方法2：重启终端
```

#### 4. 测试

```bash
# 测试别名
mc --version
mc --help
mc -c "Hello World"
```

### 优点

- ✅ **最简单**：一行配置搞定
- ✅ **立即生效**：`source ~/.bashrc` 后立即可用
- ✅ **灵活**：可以随时修改或删除
- ✅ **可传参**：支持所有参数和选项

### 缺点

- ❌ **仅限 Bash**：只在 Bash shell 中生效（zsh 需要改 `.zshrc`）
- ❌ **用户特定**：只对当前用户有效
- ❌ **非真实命令**：`which mc` 找不到（显示 `alias mc='my_cli'`）

### 适用场景

- ✅ 个人开发使用
- ✅ 快速测试和学习
- ✅ 不需要在脚本中调用

---

## 🛠️ 方案2：多入口点（最规范）

### 原理

在 `setup.py` 和 `pyproject.toml` 中同时定义 `my_cli` 和 `mc` 两个入口点，安装时会同时创建两个命令。

### 实现步骤

#### 1. 修改 `setup.py`

```python
# setup.py
from setuptools import setup, find_packages

setup(
    name="my-cli",
    version="0.1.0",
    packages=find_packages(),
    python_requires=">=3.10",
    install_requires=[
        "click>=8.1.0",
    ],
    entry_points={
        "console_scripts": [
            "my_cli=my_cli.cli:my_cli",  # 原命令
            "mc=my_cli.cli:my_cli",      # 别名命令 ← 新增这一行
        ],
    },
    author="Your Name",
    description="My CLI - 从零开始构建你自己的 AI Agent",
)
```

#### 2. 修改 `pyproject.toml`

```toml
[project]
name = "my-cli"
version = "0.1.0"
requires-python = ">=3.10"
dependencies = [
    "click>=8.1.0",
]

[project.scripts]
my_cli = "my_cli.cli:my_cli"  # 原命令
mc = "my_cli.cli:my_cli"      # 别名命令 ← 新增这一行

[project.optional-dependencies]
stage4 = ["aiofiles>=23.0.0"]
stage5 = ["pydantic>=2.0.0", "openai>=1.0.0"]
stage6 = ["rich>=13.0.0", "prompt-toolkit>=3.0.0"]

[build-system]
requires = ["setuptools>=61.0"]
build-backend = "setuptools.build_meta"
```

#### 3. 重新安装

```bash
# 在 conda 环境中
conda activate my_cli

# 重新安装（-e 是开发模式）
uv pip install -e .

# 或使用 make
make prepare
```

#### 4. 验证

```bash
# 检查命令是否创建成功
which my_cli
which mc
# 应该都能找到，且指向同一个位置

# 测试
mc --version
mc -c "Hello World"
```

### 优点

- ✅ **真实命令**：`mc` 是真正的可执行命令
- ✅ **全局可用**：在环境中任何地方都能用
- ✅ **脚本友好**：可以在 shell 脚本中调用
- ✅ **跨 shell**：Bash、Zsh、Fish 都能用
- ✅ **规范**：符合 Python 包管理最佳实践

### 缺点

- ❌ **需要重装**：每次修改后需要重新安装包
- ❌ **占用命令名**：`mc` 可能与其他工具冲突（如 Midnight Commander）

### 适用场景

- ✅ 正式项目发布
- ✅ 团队协作开发
- ✅ 需要在脚本中调用
- ✅ 跨平台使用

---

## 🔗 方案3：符号链接（折中方案）

### 原理

在 conda 环境的 `bin/` 目录下创建 `mc` 符号链接，指向 `my_cli` 命令。

### 实现步骤

#### 1. 找到 `my_cli` 命令位置

```bash
# 激活环境
conda activate my_cli

# 查找命令位置
which my_cli
# 输出：/home/seeback/.conda/envs/my_cli/bin/my_cli
```

#### 2. 创建符号链接

```bash
# 进入 bin 目录
cd ~/.conda/envs/my_cli/bin/

# 创建符号链接
ln -s my_cli mc

# 验证
ls -l mc
# 输出：mc -> my_cli
```

#### 3. 测试

```bash
# 测试别名
mc --version
mc -c "Hello World"
```

### 优点

- ✅ **不需修改代码**：不用改 `setup.py` 或 `pyproject.toml`
- ✅ **真实命令**：`which mc` 能找到
- ✅ **立即生效**：创建后立即可用

### 缺点

- ❌ **环境特定**：只在 `my_cli` conda 环境中有效
- ❌ **手动维护**：重新安装包后需要重新创建链接
- ❌ **不规范**：不是标准的 Python 包管理方式

### 适用场景

- ✅ 临时测试使用
- ✅ 不想修改代码
- ✅ 只在特定环境中使用

---

## 🎯 推荐方案总结

### 对于你的学习场景

**推荐：方案1（Shell 别名）+ 方案2（多入口点）结合**

#### 阶段1：当前学习阶段（使用方案1）

```bash
# 立即添加别名，快速开始学习
echo "alias mc='my_cli'" >> ~/.bashrc
source ~/.bashrc
```

**优点**：
- 快速开始，不用等重新安装
- 简单直接，容易理解
- 随时可以改回去

#### 阶段2：深入开发阶段（升级到方案2）

当你对项目更熟悉后，修改配置文件添加真正的入口点：

```bash
# 1. 修改 setup.py 和 pyproject.toml（添加 mc 入口点）
# 2. 重新安装
make prepare
# 3. 删除 .bashrc 中的别名（可选）
```

**优点**：
- 更规范，符合最佳实践
- 为后续分享和发布做准备
- 团队协作友好

---

## 🔧 实战操作

### 快速实现（推荐）

```bash
# 1. 添加别名到 .bashrc
echo "# My CLI 命令别名" >> ~/.bashrc
echo "alias mc='my_cli'" >> ~/.bashrc

# 2. 重新加载配置
source ~/.bashrc

# 3. 测试
mc --version

# 完成！🎉
```

### 验证别名是否生效

```bash
# 方法1：直接运行
mc --help

# 方法2：查看别名定义
alias | grep mc
# 输出：alias mc='my_cli'

# 方法3：使用 type 命令
type mc
# 输出：mc is aliased to 'my_cli'
```

---

## 🐛 常见问题

### Q1: 别名不生效怎么办？

**可能原因1：没有重新加载配置**

```bash
# 解决：重新加载
source ~/.bashrc
```

**可能原因2：使用的是 Zsh 而不是 Bash**

```bash
# 检查当前 shell
echo $SHELL

# 如果是 zsh，改为编辑 .zshrc
echo "alias mc='my_cli'" >> ~/.zshrc
source ~/.zshrc
```

### Q2: `mc` 与其他工具冲突？

```bash
# 检查是否已有 mc 命令
which mc

# 如果有（比如 Midnight Commander），换个名字
alias m='my_cli'      # 更短
alias mycli='my_cli'  # 更清晰
```

### Q3: 多入口点安装后找不到 `mc` 命令？

```bash
# 检查安装是否成功
pip list | grep my-cli

# 检查入口点是否正确
cat setup.py | grep entry_points -A 5

# 重新安装
pip uninstall my-cli
uv pip install -e .
```

### Q4: 别名在脚本中不生效？

```bash
# Shell 脚本默认不加载别名
# 解决方法1：在脚本中启用别名
#!/bin/bash
shopt -s expand_aliases
source ~/.bashrc

# 解决方法2：使用完整命令
my_cli -c "Hello World"

# 解决方法3：升级到方案2（多入口点）
```

---

## 📚 延伸知识

### Shell 别名的工作原理

```bash
# 别名本质是文本替换
alias mc='my_cli'

# 当你输入
mc --version

# Shell 会替换为
my_cli --version

# 所以别名可以包含参数
alias mc-test='my_cli -c "Hello World"'
# 运行 mc-test 等于运行 my_cli -c "Hello World"
```

### 入口点的工作原理

```python
# setup.py 中的 entry_points
entry_points={
    "console_scripts": [
        "mc=my_cli.cli:my_cli",
    ],
}

# 安装时会创建一个可执行脚本
# ~/.conda/envs/my_cli/bin/mc

# 脚本内容类似：
#!/home/seeback/.conda/envs/my_cli/bin/python
import sys
from my_cli.cli import my_cli
sys.exit(my_cli())
```

---

## 🎓 总结

| 使用场景 | 推荐方案 | 命令 |
|----------|----------|------|
| **个人学习**（当前） | 方案1：Shell 别名 | `echo "alias mc='my_cli'" >> ~/.bashrc && source ~/.bashrc` |
| **深入开发** | 方案2：多入口点 | 修改 `setup.py` 和 `pyproject.toml`，`make prepare` |
| **快速测试** | 方案3：符号链接 | `ln -s my_cli mc` |
| **团队协作** | 方案2：多入口点 | 规范、可维护 |
| **正式发布** | 方案2：多入口点 | 专业、跨平台 |

---

**现在你可以根据需求选择方案了！** 🚀

**老王推荐**：先用方案1快速开始学习，等熟悉项目后升级到方案2！